A regular language is any language that can be recognized with a DFA.
Formally a DFA is a tuple $(Q,\Sigma,\delta,q_0,F)$. Where:

\begin{tabular}{rp{0.79\linewidth}}
$Q$             & A finite, non-empty set of states. \\
$\Sigma$        & A finite, non-empty alphabet. \\
$\delta$        & A function ($\delta : Q \times \Sigma \to Q$) that maps
                  a state, and an input in $\Sigma$ to a new state. \\
$q_0$           & A state in $Q$ that DFA starts execution from. \\
$F \subseteq Q$ & A finite, possibly empty, set of accepting states.
\end{tabular}
Alternatively, regular languages can be defined by an NFA. Formally, NFAs are
the same as DFAs, except the $\delta$ function for NFAs is defined as:
\[
    \delta : Q \times (\Sigma \cup \{\varepsilon\}) \spto 2^Q
\]
Where $2^Q$ represents the power-set of $Q$. Basically, the delta function can
now map an input to multiple states instead of just one state.

\subsection{Closures}
Where $R$ is a regular language, $L$ is `not regular', and $?$ is Unknown.

% Figure out the width of the third coulumn
\settowidth{\templength}{$R \cap R \spto R$}
\addtolength{\templength}{1cm}
\begin{tabular}{lp{\templength}l}
\textbf{Closed:}       &                    & \textbf{Unclosed:} \\
$\overline{R} \spto R$ & $h(R) \spto R$     & $R \cap L \spto ?$ \\
$R^* \spto R$          & $R \cup R \spto R$ & $R \cup L \spto ?$\\
$R^R \spto R$          & $R \cap R \spto R$ & $L \cup L \spto ?$\\
$RR \spto R$           & $R \spbackslash R \spto R$ & \\
\end{tabular}

% - Pumping lemma shortcuts
\subsection{Pumping Lemma}
\begin{align*}
\exists N \in \mathbb{N}: & \\
         \forall w \in L: &\; |w| \geq N \impl \\
\exists xyz \in \Sigma^*: & \quad w = xyz \\
                          & \land |xy| \leq N \\
                          & \land y \neq \varepsilon \\
                          & \land \forall i \geq 0: xy^iz \in L
\end{align*}
\subsection{Operations}
\begin{description}
    \item[{\small DFA Negation:}] Mark all non-final states final and all final
    states non-final.

    \item[{\small DFA Reversal:}] Introduce a new initial state `$q_I$'. Add $\varepsilon$
    transitions from this new state to all old final states and mark these states
    as non-final. Reverse all arrows in the DFA, and then mark the old initial
    state $q_0$ as final.

    \item[{\small DFA Concatenating ($AB$):}] Add $\varepsilon$ transitions from
    all of $A$'s final states to $B$'s initial state. Mark $A$'s final states
    as non-final.

    \item[{\small DFA Union ($A \cup B$):}] Set the $Q$ parameter of the new
    DFA to $A$'s $Q$ crossed with $B$'s $Q$: $Q_{\text{new}} = A_Q \times B_Q$, 
    $Q$ will now contain pairs. Now change the $\delta$ function to be in terms 
    of both $A$'s delta function and $B$'s delta function: 
    $\delta_{\text{new}} = f((q_A, q_B), s) \spto (\delta_A(q_A, s)\spc \delta_B(q_B, s))$.
    That is to say, if $A$ had state $q0_A$ that went to state $q1_A$ on input 0,
    and $B$ had state $q2_B$ that went to state $q3_B$ state on input 0, then
    the new state $(q0_A, q2_B)$ would go to state $(q1_A, q3_B)$ on input 0.

    The state that contains both DFA's initial state becomes the new initial state.
    New states where \textbf{either} item in the pair were final states, become
    final.
    
    \item[{\small DFA Intersection ($A \cap B$):}] Exactly the same as DFA union
    except only pairs of state where \textbf{both} states in the pair are final
    become final states.
\end{description}

\subsection{Conversions}
\subsubsection{NFA to DFA}
\subsubsection{RE to NFA}
\subsubsection{DFA to RE}

% -! DFA minimization
%   - Table-construction algorithm
\subsection{DFA Minimization}

    \subsubsection{Table Conversion Algorithm}
    \subsubsection{Brzozowski's Algorithm}
    This algorithm is quite simple. The crux of it is that an NFA to DFA conversion
    naturally results in a minimization of the NFA. So the algorithm is as-follows:
    Take a DFA, reverse it to get an NFA, convert that NFA to a DFA again, take
    this new reversed DFA and reverse it to get the original language back, then
    convert the NFA resulting from the reversal into a DFA.
